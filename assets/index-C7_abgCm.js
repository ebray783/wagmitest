import{n as y,e as z,s as q,B as b,a as E,i as N,b as D,I as x,c as R,d as v,f as F,g as M,p as g,A as C,h as k,j,k as B,r as O,l as A,w as U,o as W,m as $,q as G,t as T,u as I,v as J,x as L,y as H,z as Q,C as K,D as V,E as X,F as Y,G as Z,H as tt}from"./index-B9pxzwsE.js";import{a8 as Nt,a9 as Dt,ac as xt,ab as Rt,ad as Ft,aa as Mt,ae as kt,af as jt,ag as Bt,J as Ot,a5 as Ut,a3 as Wt,a6 as $t,ah as Gt,aj as Jt,ak as Lt,K as Ht,L as Qt,al as Kt,N as Vt,P as Xt,Q as Yt,R as Zt,M as ta,N as aa,O as sa,P as ea,Q as na,R as ra,ai as oa,a4 as ia,S as ca,a7 as ua,T as da,U as la,V as ha,W as pa,X as fa,am as ga,Y as ya,Z as ma,_ as wa,_ as Ca,an as ba,a1 as Ta,a1 as Ea,$ as Ia,a0 as va,a2 as Aa}from"./index-B9pxzwsE.js";import{i as at}from"./isAddressEqual-BvgEeD-5.js";async function st(t,{chain:a}){const{id:s,name:e,nativeCurrency:n,rpcUrls:o,blockExplorers:r}=a;await t.request({method:"wallet_addEthereumChain",params:[{chainId:y(s),chainName:e,nativeCurrency:n,rpcUrls:o.default.http,blockExplorerUrls:r?Object.values(r).map(({url:c})=>c):void 0}]},{dedupe:!0,retryCount:0})}function et(t,a){const{abi:s,args:e,bytecode:n,...o}=a,r=z({abi:s,args:e,bytecode:n});return q(t,{...o,...o.authorizationList?{to:null}:{},data:r})}class nt extends b{constructor({domain:a}){super(`Invalid domain "${E(a)}".`,{metaMessages:["Must be a valid EIP-712 domain."]})}}class rt extends b{constructor({primaryType:a,types:s}){super(`Invalid primary type \`${a}\` must be one of \`${JSON.stringify(Object.keys(s))}\`.`,{docsPath:"/api/glossary/Errors#typeddatainvalidprimarytypeerror",metaMessages:["Check that the primary type is a key in `types`."]})}}class ot extends b{constructor({type:a}){super(`Struct type "${a}" is invalid.`,{metaMessages:["Struct type must not be a Solidity type."],name:"InvalidStructTypeError"})}}function it(t){const{domain:a,message:s,primaryType:e,types:n}=t,o=(l,i)=>{const d={...i};for(const u of l){const{name:h,type:f}=u;f==="address"&&(d[h]=d[h].toLowerCase())}return d},r=n.EIP712Domain?a?o(n.EIP712Domain,a):{}:{},c=(()=>{if(e!=="EIP712Domain")return o(n[e],s)})();return E({domain:r,message:c,primaryType:e,types:n})}function ct(t){const{domain:a,message:s,primaryType:e,types:n}=t,o=(r,c)=>{for(const l of r){const{name:i,type:d}=l,u=c[i],h=d.match(N);if(h&&(typeof u=="number"||typeof u=="bigint")){const[p,w,_]=h;y(u,{signed:w==="int",size:Number.parseInt(_)/8})}if(d==="address"&&typeof u=="string"&&!D(u))throw new x({address:u});const f=d.match(R);if(f){const[p,w]=f;if(w&&v(u)!==Number.parseInt(w))throw new F({expectedSize:Number.parseInt(w),givenSize:v(u)})}const m=n[d];m&&(dt(d),o(m,u))}};if(n.EIP712Domain&&a){if(typeof a!="object")throw new nt({domain:a});o(n.EIP712Domain,a)}if(e!=="EIP712Domain")if(n[e])o(n[e],s);else throw new rt({primaryType:e,types:n})}function ut({domain:t}){return[typeof(t==null?void 0:t.name)=="string"&&{name:"name",type:"string"},(t==null?void 0:t.version)&&{name:"version",type:"string"},(typeof(t==null?void 0:t.chainId)=="number"||typeof(t==null?void 0:t.chainId)=="bigint")&&{name:"chainId",type:"uint256"},(t==null?void 0:t.verifyingContract)&&{name:"verifyingContract",type:"address"},(t==null?void 0:t.salt)&&{name:"salt",type:"bytes32"}].filter(Boolean)}function dt(t){if(t==="address"||t==="bool"||t==="string"||t.startsWith("bytes")||t.startsWith("uint")||t.startsWith("int"))throw new ot({type:t})}async function lt(t){var s;return((s=t.account)==null?void 0:s.type)==="local"?[t.account.address]:(await t.request({method:"eth_accounts"},{dedupe:!0})).map(e=>M(e))}async function ht(t){return await t.request({method:"wallet_getPermissions"},{dedupe:!0})}async function pt(t,a={}){const{account:s=t.account,chainId:e}=a,n=s?g(s):void 0,o=await t.request({method:"wallet_getCapabilities",params:[n==null?void 0:n.address]}),r={};for(const[c,l]of Object.entries(o))r[Number(c)]=l;return typeof e=="number"?r[e]:r}async function ft(t,a){const{account:s=t.account,capabilities:e,chain:n=t.chain,forceAtomic:o=!1,id:r,version:c="2.0.0"}=a;if(typeof s>"u")throw new C({docsPath:"/experimental/eip5792/sendCalls"});const l=s?g(s):null,i=a.calls.map(d=>{const u=d;return{data:u.abi?k({abi:u.abi,functionName:u.functionName,args:u.args}):u.data,to:u.to,value:u.value?y(u.value):void 0}});try{const d=await t.request({method:"wallet_sendCalls",params:[{atomicRequired:o,calls:i,capabilities:e,chainId:y(n.id),from:l==null?void 0:l.address,id:r,version:c}]},{retryCount:0});return typeof d=="string"?{id:d}:d}catch(d){throw j(d,{...a,account:l,chain:a.chain})}}async function P(t,a){const{atomic:s=!1,chainId:e,receipts:n,version:o="2.0.0",...r}=await t.request({method:"wallet_getCallsStatus",params:[a.id]}),[c,l]=(()=>{const i=r.status;return i>=100&&i<200?["pending",i]:i>=200&&i<300?["success",i]:i>=300&&i<700?["failure",i]:i==="CONFIRMED"?["success",200]:i==="PENDING"?["pending",100]:[void 0,i]})();return{...r,atomic:s,chainId:e?B(e):void 0,receipts:(n==null?void 0:n.map(i=>({...i,blockNumber:A(i.blockNumber),gasUsed:A(i.gasUsed),status:O[i.status]})))??[],statusCode:l,status:c,version:o}}async function gt(t,a){const{id:s}=a;await t.request({method:"wallet_showCallsStatus",params:[s]})}async function yt(t,a){const{id:s,pollingInterval:e=t.pollingInterval,status:n=({statusCode:h})=>h>=200,timeout:o=6e4}=a,r=E(["waitForCallsStatus",t.uid,s]),{promise:c,resolve:l,reject:i}=U();let d;const u=W(r,{resolve:l,reject:i},h=>{const f=$(async()=>{const m=p=>{clearTimeout(d),f(),p(),u()};try{const p=await P(t,{id:s});if(!n(p))return;m(()=>h.resolve(p))}catch(p){m(()=>h.reject(p))}},{interval:e,emitOnBegin:!0});return f});return d=o?setTimeout(()=>{u(),clearTimeout(d),i(new mt({id:s}))},o):void 0,await c}class mt extends b{constructor({id:a}){super(`Timed out while waiting for call bundle with id "${a}" to be confirmed.`,{name:"WaitForCallsStatusTimeoutError"})}}async function wt(t){return(await t.request({method:"eth_requestAccounts"},{dedupe:!0,retryCount:0})).map(s=>G(s))}async function Ct(t,a){return t.request({method:"wallet_requestPermissions",params:[a]},{retryCount:0})}async function S(t,a){var l;const{account:s=t.account,chainId:e,nonce:n}=a;if(!s)throw new C({docsPath:"/docs/eip7702/prepareAuthorization"});const o=g(s),r=(()=>{if(a.executor)return a.executor==="self"?a.executor:g(a.executor)})(),c={address:a.contractAddress??a.address,chainId:e,nonce:n};return typeof c.chainId>"u"&&(c.chainId=((l=t.chain)==null?void 0:l.id)??await T(t,I,"getChainId")({})),typeof c.nonce>"u"&&(c.nonce=await T(t,J,"getTransactionCount")({address:o.address,blockTag:"pending"}),(r==="self"||r!=null&&r.address&&at(r.address,o.address))&&(c.nonce+=1)),c}async function bt(t,a){const{account:s=t.account}=a;if(!s)throw new C({docsPath:"/docs/eip7702/signAuthorization"});const e=g(s);if(!e.signAuthorization)throw new L({docsPath:"/docs/eip7702/signAuthorization",metaMessages:["The `signAuthorization` Action does not support JSON-RPC Accounts."],type:e.type});const n=await S(t,a);return e.signAuthorization(n)}async function Tt(t,a){var i,d,u,h;const{account:s=t.account,chain:e=t.chain,...n}=a;if(!s)throw new C({docsPath:"/docs/actions/wallet/signTransaction"});const o=g(s);H({account:o,...a});const r=await T(t,I,"getChainId")({});e!==null&&Q({currentChainId:r,chain:e});const c=(e==null?void 0:e.formatters)||((i=t.chain)==null?void 0:i.formatters),l=((d=c==null?void 0:c.transactionRequest)==null?void 0:d.format)||K;return o.signTransaction?o.signTransaction({...n,chainId:r},{serializer:(h=(u=t.chain)==null?void 0:u.serializers)==null?void 0:h.transaction}):await t.request({method:"eth_signTransaction",params:[{...l(n),chainId:y(r),from:o.address}]},{retryCount:0})}async function Et(t,a){const{account:s=t.account,domain:e,message:n,primaryType:o}=a;if(!s)throw new C({docsPath:"/docs/actions/wallet/signTypedData"});const r=g(s),c={EIP712Domain:ut({domain:e}),...a.types};if(ct({domain:e,message:n,primaryType:o,types:c}),r.signTypedData)return r.signTypedData({domain:e,message:n,primaryType:o,types:c});const l=it({domain:e,message:n,primaryType:o,types:c});return t.request({method:"eth_signTypedData_v4",params:[r.address,l]},{retryCount:0})}async function It(t,{id:a}){await t.request({method:"wallet_switchEthereumChain",params:[{chainId:y(a)}]},{retryCount:0})}async function vt(t,a){return await t.request({method:"wallet_watchAsset",params:a},{retryCount:0})}function At(t){return{addChain:a=>st(t,a),deployContract:a=>et(t,a),getAddresses:()=>lt(t),getCallsStatus:a=>P(t,a),getCapabilities:()=>pt(t),getChainId:()=>I(t),getPermissions:()=>ht(t),prepareAuthorization:a=>S(t,a),prepareTransactionRequest:a=>Z(t,a),requestAddresses:()=>wt(t),requestPermissions:a=>Ct(t,a),sendCalls:a=>ft(t,a),sendRawTransaction:a=>Y(t,a),sendTransaction:a=>q(t,a),showCallsStatus:a=>gt(t,a),signAuthorization:a=>bt(t,a),signMessage:a=>X(t,a),signTransaction:a=>Tt(t,a),signTypedData:a=>Et(t,a),switchChain:a=>It(t,a),waitForCallsStatus:a=>yt(t,a),watchAsset:a=>vt(t,a),writeContract:a=>V(t,a)}}async function St(t,a={}){return(await tt(t,a)).extend(At)}export{Nt as BaseError,Dt as ChainNotConfiguredError,xt as ConnectorAccountNotFoundError,Rt as ConnectorAlreadyConnectedError,Ft as ConnectorChainMismatchError,Mt as ConnectorNotConnectedError,kt as ConnectorUnavailableReconnectingError,jt as ProviderNotFoundError,Bt as SwitchChainNotSupportedError,Ot as connect,Ut as createConfig,Wt as createConnector,$t as createStorage,Gt as custom,Jt as deepEqual,Lt as deserialize,Ht as disconnect,Qt as estimateGas,Kt as extractRpcUrls,Vt as fetchBalance,Xt as fetchEnsAddress,Yt as fetchEnsAvatar,Zt as fetchEnsName,ta as getAccount,aa as getBalance,sa as getConnections,tt as getConnectorClient,ea as getEnsAddress,na as getEnsAvatar,ra as getEnsName,St as getWalletClient,oa as http,ia as injected,ca as multicall,ua as noopStorage,da as prepareTransactionRequest,la as readContract,ha as readContracts,pa as reconnect,fa as sendTransaction,ga as serialize,ya as signMessage,ma as switchAccount,wa as switchChain,Ca as switchNetwork,ba as version,Ta as waitForTransaction,Ea as waitForTransactionReceipt,Ia as watchAccount,va as watchConnectors,Aa as writeContract};
